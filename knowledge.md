Live upgrades
=============

appup and relup files are generated for automatic live upgrade

There have to be two tags in git and the app.src has to contain ```{vsn, git}```.
$BASE and $TARGET versions are upgrade vector.

how to generate:

``` shell
git reset --hard $BASE
rebar3 release
rebar3 sappan checkrel

git reset --hard $TARGET
rebar3 release
rebar3 appup generate -g default=brutal/soft
rebar3 sappan generate_config
rebar3 sappan checkrel
rebar3 sappan check_upgrade
rebar3 relup
rebar3 tar   
```

Then open relup file and check instructions; If needed, use following code to reorder instuctions.
In this example instruction ```{apply, {...}}``` will be run directly after ```{add_module}```

```
% rebar.config
{sappan, [
    {post_instrs_upgrade, [
        {{add_module, cfg_storage, []}, [
            {apply,{cfg_storage,init_backends_table, []}}
        ]}
    ]}
]}.

```

Proper
=======

While doing statefull testing with proper, first generate tests in existing project by
```rebar3 new proper_statem <<name>>```.

If am I restricting commands generated by _command/1_ using its state, I should duplicate these
constraints into _precondition/3_ or move it into precondition. The reason is that
the _precondition/3_ is used for shrinking as well.

Common Tests
============

While testing the library application via common tests, it is needed to run
`application:ensure_all_started` first, even though it is not needed when playing in shell.
