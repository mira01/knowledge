Live upgrades
=============

appup and relup files are generated for automatic live upgrade

There have to be two tags in git and the app.src has to contain ```{vsn, git}```.
$BASE and $TARGET versions are upgrade vector.

how to generate:

``` shell
git reset --hard $BASE
rebar3 release
rebar3 sappan checkrel

git reset --hard $TARGET
rebar3 release
rebar3 appup generate -g default=brutal/soft
rebar3 sappan generate_config
rebar3 sappan checkrel
rebar3 sappan check_upgrade
rebar3 relup
rebar3 tar   
```

Then open relup file and check instructions; If needed, use following code to reorder instuctions.
In this example instruction ```{apply, {...}}``` will be run directly after ```{add_module}```

```
% rebar.config
{sappan, [
    {post_instrs_upgrade, [
        {{add_module, cfg_storage, []}, [
            {apply,{cfg_storage,init_backends_table, []}}
        ]}
    ]}
]}.

```

Proper
=======

While doing statefull testing with proper, first generate tests in existing project by
```rebar3 new proper_statem <<name>>```.

If am I restricting commands generated by _command/1_ using its state, I should duplicate these
constraints into _precondition/3_ or move it into precondition. The reason is that
the _precondition/3_ is used for shrinking as well.

Common Tests
============

While testing the library application via common tests, it is needed to run
`application:ensure_all_started` first, even though it is not needed when playing in shell.

Running Common Tests from Erlang shell
--------------------------------------

To speed up running tests, it's possible to run common tests from running erlang shell. The advantage is that all buiding is done once. Run `rebar3 as test shell` and then `ct:run_test(Opts)` where Opts is build from cli argument in following way [https://www.erlang.org/doc/apps/common_test/run_test_chapter#running-tests-from-the-erlang-shell-or-from-an-erlang-program](https://www.erlang.org/doc/apps/common_test/run_test_chapter#running-tests-from-the-erlang-shell-or-from-an-erlang-program). Put simply: it is a list where single cli param is passed as atom and cli params taking argument are tuples with atom key.

Example:

```
ct:run_test([{name, "ct"}, {sys_config, "config/sys.config"}, {readable, true}, cover, {verbose, true}, {logdir, "log/tests"}, {include, "include"}]).
```

Note the passed {include, "include"}: it is path to include directory, which is needed to sucessfull compilation of tests.
